<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en" lang="en">
<head>
<meta charset="utf-8"/>
<title>Computers in Chemistry</title>
<link rel="stylesheet" href="../styles/stylesheet.css" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<section epub:type="chapter" id="ch05">
<a id="page_53" class="page" style="width:70%;">Page 53, Chapter 5 Software for the laboratory</a>
<h1 class="main"><b>5<span class="space">&#160;</span>Software for the laboratory</b></h1>
<p class="banoindent">The previous chapter introduced some of the programming techniques used in creating the software used in instrumentation. In this section, we will look more at what the software does.</p>
<section epub:type="chapter" id="ch5.1">
<h2 class="h2"><b>5.1 Background</b></h2>
<p class="banoindent">It will come as a relief to most people that it is not necessary to write all the instrumentation software yourself; indeed it is easily possible to produce a working, useful system to control an instrument from a computer using off-the-shelf hardware and software. Further, most modern instruments were designed with computer control in mind, and many are essentially useless without that computer control. Take as an example the development of UV-Vis or infra-red spectrometers. Ancient instruments (<i>i.e</i>. pre 1970&#x2019;s) were generally electromechanical in design and completely stand-alone. Now, similar instruments have either inputs and outputs to allow interaction with external devices, or are completely dependent on computer control.</p>
<p class="baindent">This computer control usually takes the form of a general-purpose computer such as a PC. There are two ways that these sorts of instruments can be configured for computer control: the spectrometer may be completely &#x2018;dumb&#x2019; and the attached PC controls every minute detail, or conversely the spectrometer may have a degree of &#x2018;intelligence&#x2019; and the PC only gives it general instructions. It is important to understand the implications of these two scenarios. If the computer is controlling even the basic functions of the instrument, then often things happen in a time-critical manner, and the computer must be available to respond when necessary. The consequence of this is that the computer will be dedicated to this one task, and can not be used for other things, such as data manipulation, while it is scanning a spectrum. If the spectrometer is intelligent, then the computer may be able to give it general commands, like &#x201C;scan from 300 nm to 400 nm at 1 nm s<sup>-1</sup>&#x201D;, and then resume other tasks while it is waiting for the scan to finish.</p>
<p class="baindent">This arrangement of one computer giving instructions to another is often called a <i>master/slave</i> set-up. The master computer, the PC, decides on the general strategy, while the slave performs the actual tasks. The slave computer may often be as powerful, if not more powerful, than the master, especially when complex actions such as Fourier transforms are required, but it is still only a slave to the master&#x2019;s desires. In some instruments, the slave computer may not be physically located in the instrument: the slave may be an interface card in the PC, the advantage of this being that the transfer of large amounts of data between the master and slave is much faster.</p>
<p class="baindent">Most modern instruments, be they spectrometers or pH meters, have some form of intelligence built into them and many are capable of working in a master/slave environment, even if they have enough built-in intelligence to be stand-alone machines. Further, those that are expected to be slave <a id="page_54" class="page">Page 54, Chapter 5 Software for the laboratory</a>machines will often have the basic abilities to act on their own. Some large instruments take this master/slave principle a stage further, with many slave processors being controlled from one master: for instance, in a modern NMR spectrometer, there will be one controlling computer, but there may be slave processors that control the magnetic fields, the cryogenic system, the detectors, the pulse generation, the Fourier transform calculations and so on.</p> <p class="baindent">One problem with all this computerisation of instrumentation is: how do you get the data from an instrument to a computer, and once it is there, what do you do with it! The rest of this chapter will deal with these two thorny issues.</p>
</section>
<section epub:type="chapter" id="ch5.2">
<h2 class="h2"><b>5.2 Linking computer and instrument</b></h2>
<p class="banoindent">There are very few standard ways of connecting a computer to an instrument; often this is because some of the processing is performed on an interface board inside the computer, and the link between the board and the device is very specialised. Since it is very unwise to interfere with such specialised situations, we will not discuss them further. General-purpose interconnection techniques fall into two main categories: serial or parallel.</p>
<h3 class="h3"><b>Serial interfaces</b></h3>
<table class="width70tb">
<tr>
<td style="vertical-align:top;border-bottom:1px solid black;" colspan="2"><p class="table" style="text-align:center;">Pin Number</p></td>
<td style="vertical-align:top;"><p class="tabler">Legend</p></td>
<td style="vertical-align:top;"><p class="t-left">Description</p></td>
</tr>
<tr>
<td style="vertical-align:top;border-bottom:1px solid black;"><p class="table">25-pin D</p></td>
<td style="vertical-align:top;border-bottom:1px solid black;"><p class="tabler">9-pin D</p></td>
<td style="vertical-align:top;border-bottom:1px solid black;"><p class="tabler"></p></td>
<td style="vertical-align:top;border-bottom:1px solid black;"><p class="tabler"></p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">2</p></td>
<td style="vertical-align:top;"><p class="t-center">3</p></td>
<td style="vertical-align:top;"><p class="t-center">XMT</p></td>
<td style="vertical-align:top;"><p class="t-left">Transmitted data</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">3</p></td>
<td style="vertical-align:top;"><p class="t-center">2</p></td>
<td style="vertical-align:top;"><p class="t-center">RCV</p></td>
<td style="vertical-align:top;"><p class="t-left">Received data</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">4</p></td>
<td style="vertical-align:top;"><p class="t-center">7</p></td>
<td style="vertical-align:top;"><p class="t-center">RTS</p></td>
<td style="vertical-align:top;"><p class="t-left">Request to send</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">5</p></td>
<td style="vertical-align:top;"><p class="t-center">8</p></td>
<td style="vertical-align:top;"><p class="t-center">CTS</p></td>
<td style="vertical-align:top;"><p class="t-left">Clear to send</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">6</p></td>
<td style="vertical-align:top;"><p class="t-center">6</p></td>
<td style="vertical-align:top;"><p class="t-center">DSR</p></td>
<td style="vertical-align:top;"><p class="t-left">Data set ready</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">7</p></td>
<td style="vertical-align:top;"><p class="t-center">5</p></td>
<td style="vertical-align:top;"><p class="t-center">&#x2014;</p></td>
<td style="vertical-align:top;"><p class="t-left">Ground</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">8</p></td>
<td style="vertical-align:top;"><p class="t-center">1</p></td>
<td style="vertical-align:top;"><p class="t-center">DCD</p></td>
<td style="vertical-align:top;"><p class="t-left">Data carrier detect</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">20</p></td>
<td style="vertical-align:top;"><p class="t-center">4</p></td>
<td style="vertical-align:top;"><p class="t-center">DTR</p></td>
<td style="vertical-align:top;"><p class="t-left">Data terminal ready</p></td>
</tr>
<tr>
<td style="vertical-align:top;"><p class="t-center">22</p></td>
<td style="vertical-align:top;"><p class="t-center">9</p></td>
<td style="vertical-align:top;"><p class="t-center">RI</p></td>
<td style="vertical-align:top;"><p class="t-left">Ring indicator</p></td>
</tr>
</table>
<p class="banoindent">A serial connection is one in which each bit of the data is sent individually down a single line, a &#x2018;1&#x2019; being represented by a high voltage on the line, and a &#x2018;0&#x2019; by a low voltage. The specific voltages involved are well defined, but vary depending on which standard is being used (see below). It is possible for serial connections to consist of just two wires (the data connection and a ground for reference), but this means that data can only be transmitted in one direction at a time, so called <i>simplex</i> connections. Most serial connections these days actually consist minimally of three wires, one each for data travel in each direction, so that transmission can occur in both directions at once, and a ground. This arrangement is called a <i>duplex</i> connection. There are often many more wires in a serial connection, and these are used for data flow control &#x2013; so that, for instance, the receiving end can indicate to the transmitting side that it is not ready to receive data yet and so on. These <i>handshaking</i> signals, although not absolutely necessary, enable much more efficient error free transfer of data and allow transmissions at much higher speeds. Serial connections most often use 25-pin or 9-pin &#x2018;D&#x2019;-connectors, and the pin-outs of these connectors are shown in <a href="#tab5.1">Table 5.1</a>.These <a id="page_55" class="page">Page 55, Chapter 5 Software for the laboratory</a>connections and connectors were developed in the days when terminals were connected to computers through serial lines, consequently many of the connections are redundant now. Other types of connectors are sometimes also employed on computers, but if this is the case, then adapters to a &#x2018;D&#x2019;-connector is often supplied.</p>
<p class="tabcap" id="tab5.1">Table 5.1 Pin-out of RS232 serial connectors</p>

<aside class="abc" style="margin-top:5em;" epub:type="sidebar">
<p class="noindent2" style="margin-left:1em;">Baud: a unit of measure of data flow, equivalent to bits s<sup>&#x2212;1</sup>.</p>
</aside>
<p class="baindent">A serial connection between computer and instrument usually uses the built in serial ports on the computer. Most often this type of interface is used in situations where the rate of data acquisition is low, or there is a small amount of data produced. This is because serial ports are inherently slow and the rate of data transfer is not very high. Take for example a serial port running at 9600 baud; each bit takes 1/9600 s (or approximately 0.1 ms) to transmit, so an 8-bit character (with overheads) takes about 1 ms; so if each f data point consists of two numbers occupying in total 10 characters, a maximum acquisition rate of 100 points/s is only possible. This may seem like a reasonable acquisition rate, but basic rates of 10 times this are often necessary. Of course, if the instrument has some form of built-in intelligence, data can be stored in the instrument and some form of pre-processing performed before transfer to the computer. Nevertheless, serial transfer can still be relatively slow: a 1000 point spectrum, for instance, will take over 10 s to transfer to the computer.</p>
<aside class="abc" style="margin-top:1em;" epub:type="sidebar">
<p class="noindent2" style="margin-left:1em;">Data transmission standards:a number of different standards exist, with the most common being RS232C. This defines &#x2018;1&#x2019; as being +15V, and a &#x2018;0&#x2019; as &#x2212;15V. Others are RS422, which uses &#x00B1;5V, and current loop, which uses a current of 40 mA to represent a &#x2018;1&#x2019; and 5mA for a &#x2018;0&#x2019;. Over long distances, the resistance of the connecting wire can attenuate the voltages used in RS232 &#x0026; RS422 lines and so possibly cause error to occur.Current loops do not suffer from this problem.</p></aside>
<p class="baindent">Serial connections are used though and they do have distinct advantages., First, and probably most importantly, they are simple and relatively easy to program: at a low level, sending characters along a serial line is as simple as writing a byte to an I/O port, with reading characters being just as simple; at a higher level, there are well documented programming interfaces to serial ports. Secondly, the electrical characteristics of a serial line are well understood and the distance between the computer and the instrument can be quite large &#x2013; standard RS232C lines (like those used in the PC) can be used over a distance of about 10 m, longer distances can be achieved using current-loop techniques.</p>
<p class="baindent">Baud rates higher than 9600 are, of course, possible, and higher rates will 1 enable data to be transferred much more quickly. But if higher speeds are used, then the maximum length of cable will be reduced, and it is imperative to use some form of handshaking.</p>
<h3 class="h3"><b>Parallel connections</b></h3>
<p class="banoindent">As the name suggests, multiple bits of data are transferred at a time when parallel connections are used. The most often encountered type of connection is 8-bit parallel, meaning that 8-bits are transferred at a time.</p>
<p class="baindent">All PCs are equipped with at least one parallel connection &#x2013; the printer port &#x2013; and some interfaces do indeed use it for connecting to instruments. But there are two disadvantages with this. First, often the port is uni-directional, i.e. the port can only transmit data, not receive it, and secondly, it is often used for a printer and so will not be available.</p> <p class="baindent">The most common type of parallel connection used to connect instruments and computers together is the <i>IEEE-488</i> or <i>GP-IB</i> bus. This system is not just a straightforward parallel connection between two devices, it is a multi-device bus arrangement. Each device on the bus has an address and any two devices may talk to each other at any one time. When two devices talk, one is <a id="page_56" class="page">Page 56, Chapter 5 Software for the laboratory</a>a master, and the other a slave; the master controls the interaction and initiates the conversation with the slave.</p> <p class="baindent">The only problem with GP-IB systems is that they are sometimes more complicated to program than straightforward serial interfaces, but the advantages of higher speed and the possibility of controlling more than one device are usually dominant.</p>
<h3 class="h3"><b>Which interface to use?</b></h3>
<p class="banoindent">This is not an easy question to answer, serial interfaces are simpler and more electrically robust, but parallel systems are much faster and more versatile. In the end though, choice may not be possible. Often an instrument comes with only one type of interface and you will be forced to use that. The skill is not really in choosing which interface to use, rather picking an instrument in the first place that offers the facilities you need.</p>
</section>
<section epub:type="chapter" id="ch5.2a">
<h2 class="h2">5.2 Data processing</h2>
<p class="banoindent">So once you have the data in your computer, what do you do with it? Well that depends on what your data represent! However, the first hurdle is to get the data into some form that is understandable by the data manipulation programs.</p>
<h3 class="h3"><b>Data formats</b></h3>
<p class="banoindent">There are very few &#x2018;standard&#x2019; data formats in use, most instruments produce data in a format that seems the most sensible to the designers of the instrument, but is totally incompatible to all others. This makes the design of data processing programs very difficult, and the approach used by most programmers is to provide translators for a number of different data formats into their own, proprietary, format.</p>
<aside class="abc" style="margin-top:3em;" epub:type="sidebar"> <p class="noindent2" style="margin-left:1em;">ASCII &#x2013; American Standard Code for Information Interchange &#x2013; the standard way of representing characters (numerals, letters, symbols) in a computer. Each character has a unique number based on a 7-bit binary word. For instance the character &#x2018;P&#x2019; is represented by 1010000 in binary, or 80 in decimal. In 8-bit computers, the extra bit is either used as a parity bit, or for the extended ASCII character set</p>
</aside>
<p class="baindent">The first thing to determine is how the data are represented: <i>i.e</i>. is it binary or is it text? The difference between binary and text is often a cause of confusion: the number 203 can either be represented by the 8-bit binary number &#x2018;11001011&#x2019; or the ASCII digits &#x2018;2&#x2019;, &#x2018;0&#x2019; and &#x2018;3&#x2019;. In general, binary data is used where very low-level data is being transferred, such as the direct output from an ADC, and ASCII is used when there has been some form of processing already applied to the data. The main advantage of binary over textual forms of data is that it is much more compact: the number 203 can be represented in 8 bits in binary and 24 bits in ASCII. However, binary data usually has a much higher degree of structure and is much more inflexible. This structure is necessary because binary data can take any possible combination of bits and so there is no room for markers to signify the start and end of data or, say, a change in scale. In general, most data formats are some form of ASCII; it is much easier to introduce a flexible structure, markers signifying &#x2018;events&#x2019; can be inserted, and, possibly most importantly, it can be read by humans. Indeed binary formats are so relatively rare, and so specialised, that they will not be discussed further here.</p> <p class="baindent">The most basic data format is a simple stream of numbers representing some phenomenon such as a spectrum. The data stream will usually consist of one number per line, and the format of that number will depend on the actual value of the data (it may be integer, real or in &#x2018;scientific&#x2019; notation). <a id="page_57" class="page">Page 57, Chapter 5 Software for the laboratory</a>Obviously, it is necessary to know beforehand what these numbers represent, since there is no way of determining from the data stream what, in the case of the spectrum, the wavelength for each data point is.</p>
<p class="baindent">The next refinement is to insert into the data stream, at a predefined point, some information that will indicate what the rest of the data refer to. Most often this is done at the start of the data, and may consist of the number of data points to expect and other pertinent data like the wavelength range and increment in our spectrum example. Again though, this header data is usually in a fixed format and so only of use to one application.</p>
<p class="baindent">Data are often best represented in groups: these groups may be anything from a single (x,y) data point to a series of measurements all taken at one time. These groups, or <i>records</i>, are often represented in data files as a single line of data, with each value being separated from the others by a comma thus giving rise to the name of this type of data file: <i>comma separated value</i>, or <i>CSV</i>, files. Most data analysis programs are able to read and write CSV data, either as simple (x,y) data or as more complex records. Consequently it is probably the most commonly used general purpose data format and is a good choice to use if you are writing a program which produces data that is to be read by another program.</p>
<p class="baindent">Beyond these simple formats lies the minefield of proprietary formats &#x2013; all of which seemed a very good idea at the time and whose authors were convinced would solve the world&#x2019;s problems. Invariably these formats are only used by a narrow range of programs in one particular field. The tragedy for scientists is that once the data have been saved in that proprietary format, it is generally unfathomable by any other program. Unless the data are exported from that program into some suitable general-purpose format, it will be almost impossible to read the data into another program. It is not unknown for valuable data to be lost because some research student has saved the experimental results in an unknown format&#x0021;</p>
<p class="baindent">Having said that most data formats are proprietary, there has recently been a move to design a general-purpose technical data format to aid in the exchange of information. This format is called <i>Hierarchical Data Format</i>, or <i>HDF</i>. One of the problems of a general-purpose format is that each experimenter has their own idea about what a data format is: some work with simple (x,y) points, whereas others may need 3D arrays, and others might use images; the individual data points may be integer, real or imaginary. Each of these formats, and more, need to be accommodated in any general-purpose system. HDF uses a system similar to a filesystem on a computer: the individual sets of data are contained within a hierarchical structure, with each set having attributes that define its contents.</p>
<h3 class="h3"><b>Keeping track of the data</b></h3>
<p class="banoindent">It is surprising how many experimenters treat the data they have just laboured over acquiring with little respect. Often they spend hours searching through files on hard or floppy disks looking for the raw data from an experiment they performed &#x201C;just last month&#x201D;.</p>
<p class="baindent">The problem is mostly one of housekeeping, but it is nevertheless important to consider. The first and most important thing is to give your data files meaningful, consistent, names. There is no point in using names such as &#x201C;data9.dat&#x201D; for your files: they convey no meaning and it would be necessary <a id="page_58" class="page">Page 58, Chapter 5 Software for the laboratory</a>to actually look at the data to find out what the file contained. There are many different naming schemes, the specific one chosen probably depends on the limitations of the computer system you are using &#x2013; the old &#x201C;8.3&#x201D; filename system used in older versions of DOS did not really encourage good naming practices&#x0021; One way is to encode the date into the filename in some way as this is often the way in which results are organised: for instance you may use names such as &#x201C;2001-10-17-000.dat&#x201D; where the last three digits indicate the file number for that day. The use of the date in &#x201C;year-month-day&#x201D; format is useful, as it will mean that the files, when listed, will be sorted in date order. Another way may be to encode the experiment type into the filename: for instance experiments on ozone photolysis at 200 K may be stored in files called &#x201C;o3phot-200K-000&#x201D;. If this method is chosen, then it is useful to store the date inside the file in some way, as the date the experiments were performed is sometimes the only way of accurately tracing the exact experimental conditions. Note that it is not sufficient to use the computer&#x2019;s in-built date stamping of files as a record of the date the files were created &#x2013; the date on the computer may be wrong, and the dates are often not replicated when the files are copied.</p>
<p class="baindent">The second useful technique to use when storing data is to organise the files into directories or folders. This may seem obvious to many people, but all too often you come across directories that contain a couple of thousand data files representing somebody&#x2019;s work over the last few years. All modern operating systems (and most ancient ones as well) offer the ability to create a hierarchical filesystem structure that can be used to create folders within folders (and so on) so that your data can be held in a logical manner. The folder structure may be based on the date (<i>i.e</i>. there is a folder for each month and subfolders for each day in the month) or it could be based on the type of experiment being performed (<i>i.e</i>. a folder for a particular compound being studied, and then subfolders for the type of experiment performed on the compound and so on). It doesn&#x2019;t really matter what the structure is so long as it is logical and consistent.</p>
<p class="baindent">It is also good practice to ensure that whenever results are presented or analysed, that the name (and folder) of the original raw data file is recorded. In this way it is always possible to go back to the original data to perform any reanalysis. Further, if the original filename is constructed in a logical, consistent, manner, it will contain information on what the graph or whatever refers to.</p>
<p class="baindent">Finally it is wise to remember that your data are precious: don&#x2019;t loose them. Always make sure that backups of the data are made at regular intervals and that the backups are readable. There are many ways of maintaining backups, but the simplest way is to copy the data to a floppy disk. If the data are particularly valuable or time-consuming to acquire, then make multiple backups. When making backups, ensure that any folder structure is retained: it is pointless making a backup, if that backup overwrites some previously saved data of the same filename.</p>
<h3 class="h3"><b>Analysing the data</b></h3>
<p class="banoindent">Before the advent of computers all data analysis was performed by hand. The technique involved getting a large piece of paper and drawing many columns on it. The raw data was entered on the left-hand side, and subsequent <a id="page_59" class="page">Page 59, Chapter 5 Software for the laboratory</a>columns contained intermediate results calculated using either log tables or a calculator until the required final result was arrived at. The most important tools were a large piece of scrap paper and an eraser. Most of the experimenter&#x2019;s time was spent trying to find out where, in all these calculations, a mistake had been made&#x0021;</p>
<p class="baindent">The advent of computers meant that these repetitive calculations could be performed in the knowledge that no mistakes would be made &#x2013; or that the same mistake would be made in every calculation. There are two methods of doing such calculations: a program written specifically for the purpose, or a general-purpose program customised to your needs. The most common type of general-purpose program used is a spreadsheet, and these will be examined below.</p>
<p class="baindent">When writing a custom program for the analysis of data there are a number of things that must be borne in mind. First, even if the program is to be used only by the programmer, it must be fully commented: if a modification needs to made to the program, it can be almost impossible to try and work out what a particular constant was or where it was derived from&#x0021; Secondly, check the output: it is a common failing that people all too readily accept the output from a computer program as being &#x201C;right&#x201D;; unfortunately, it is only as correct as the original programming. It is advisable to check the output from the program by inputing data that has been previously calculated by hand and is known to be correct; a further good test is for a second person to calculate input data backwards assuming an answer, and then checking that the analysis program does indeed come up with the correct answer. Finally, make sure that any printout from the program contains a record of what the data refer to: a sheet of numbers means nothing a couple of months later&#x0021;</p>
<h3 class="h3"><b>Spreadsheets</b></h3>
<p class="banoindent">A spreadsheet can be likened to the Dickensian ledgers that the likes of Bob Cratchett slaved over. Numbers are entered into rows and columns, the results of calculations on these numbers are entered in to other rows and columns and so on. If one number is changed, then that change must be reflected in all the numbers that depend on it. A spreadsheet performs all these dependent calculations automatically when any entry in a <i>cell</i> is changed. Each cell can be either a value or a formula specifying how the value of the cell can be calculated.</p>
<p class="baindent">A full description of spreadsheets is well beyond the scope of this book, but it is obvious how they can be used to help an experimenter perform repetitive calculations. A small example of a spreadsheet is shown in <a href="#fig5.1">Fig. 5.1</a> (the actual data are fictitious and have been generated solely for this purpose).</p>
<p class="baindent">The calculation in <a href="#fig5.1">Fig. 5.1</a> is to measure the concentration of compound X in substance Y; compound X is extracted from Y by a solvent twice (solutions &#x2018;1&#x2019; and &#x2018;2&#x2019;). The concentration of X in the solutions is then measured. The calculation thus consists of</p>
<table class="fig1a"><tr><td><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<msub><mrow><mo>[</mo><mtext>X</mtext><mo>]</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>Y</mtext></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">[</mo><mtext>X</mtext><msub><mo stretchy="false">]</mo><mrow class="MJX-TeXAtom-ORD"><mtext>S</mtext><mn>1</mn></mrow></msub><mo>&#x22C5;</mo><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><mo>+</mo><mo stretchy="false">[</mo><mtext>X</mtext><msub><mo stretchy="false">]</mo><mrow class="MJX-TeXAtom-ORD"><mtext>S</mtext><mn>2</mn></mrow></msub><mo>&#x22C5;</mo><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msub></mrow><msub><mi>W</mi><mtext>Y</mtext></msub></mfrac></math></td><td>(5.1)</td></tr></table>
<p class="noindent"><a id="page_60" class="page" style="width:70%;">Page 60, Chapter 5 Software for the laboratory</a></p>
<p class="baindent">In the spreadsheet, the weight of substance Y (<i>W</i><sub>Y</sub>) is in column B, the measured concentrations of X in solution ([X]<sub>s1</sub>, [X]<sub>s2</sub>) are in columns C and F and the volumes of solutions 1 and 2 are in cells C3 and C4. The amount of X in each solution is calculated (by [X]<sub>s</sub>.<i>V</i>) in columns D and G by multiplying the value in columns C and F by cells C3 and C4 respectively. The intermediate solid concentrations are derived in columns E and H by dividing the values calculated in D and G by the weight of the sample in column B. The total amount of compound X, derived from the sum of columns D and G is in column J, with the final concentration, calculated by dividing the values in J by the corresponding value in B, being shown in column K.</p>
<figure class="banoindentt" id="fig5.1" style="width:100%;">
<img src="../images/page60-1.jpg" alt="images"/>
<figcaption class="fig1" style="text-align:left;margin-left:0em;">Fig. 5.1 Example demonstrating the use of a spreadsheet</figcaption>
</figure>
<p class="baindent">The formulae used to perform these calculations are shown in row 22. The &#x2018;&#xFE69;&#x2019; prefix to a cell reference means that that reference is fixed (<i>i.e</i>. it doesn&#x2019;t change down the column, whereas the others will change); fixed cells are used here to point to the volumes in cells C3 and C4.</p>
<p class="baindent">Finally, the average and standard deviation at the foot of column K are calculated using built-in functions. Most spreadsheets contain such functions, and in MS Excel (the one used here), the cells contain the formulae AVERAGE(K9:K18) and STDEVP(K9:K18).</p>
<p class="baindent">The advantage of using spreadsheets over &#x2018;pen and paper&#x2019; is that once a basic spreadsheet has been constructed, all that is necessary to repeat the calculation in a similar experiment is to change the raw data &#x2013; in this case the data in columns B, C and F.<a id="page_61" class="page">Page 61, Chapter 5 Software for the laboratory</a></p>
<h3 class="h3"><b>Plotting results</b></h3>
<p class="banoindent">Almost all data needs to be plotted at one point or another. Experimenters are, of course, still at liberty to use graph paper and pencil, and many still do. However, it seems sensible that as most data are now either collected by, or entered into, a computer, that we use its facilities for plotting the data.</p>
<p class="baindent">Probably the easiest way to plot data on a personal computer, be it a PC or a Mac, is to use a spreadsheet. All modern spreadsheets have some form of plotting functions built into them. However, it must be remembered that the spreadsheet was originally designed as an office, not a scientific, tool, and as such the range of scientific plotting facilities is usually very limited. For instance, probably the most popular spreadsheet package in use, Microsoft Excel, has only 1 out of 14 graph types that is suitable for plotting (x,y) data&#x0021;</p>
<p class="baindent">There are, of course, other methods of plotting data. Most LIMS packages (see below) incorporate some form of graphical capability and these systems may be the most convenient integrated way of analysing data. Dedicated plotting packages exist as well. For the PC, packages such as Origin from Microcal provide very accomplished plotting facilities along with spreadsheet style data manipulation tools. For Unix machines, there are many very powerful packages available: AVS, Unigraph, IDL amongst many others are very versatile commercially available packages, whilst excellent public domain packages such as Ace/GR (xmgr &#xFE60; xvgr) and gnuPlot encompass all but the most esoteric plotting facilities.</p>
<p class="baindent">Details of the techniques of plotting will be covered later in <a href="Chapter07.xhtml">Chapter 7</a>.</p>
<h3 class="h3"><b>Handling errors</b></h3>
<p class="banoindent">It is important in any experimental situation to be acutely aware of sources of error. Errors can be introduced at many stages including statistical random fluctuations in the data, errors and inaccuracies in the measurements, inaccuracies in the calculations (<i>e.g</i>. rounding errors) and inaccuracies in other people&#x2019;s results.</p>
<p class="baindent">Many excellent volumes have been written on error handling, and it is not the intention to go into detail here except to say that a good understanding of errors, their propagation and their minimisation goes a long way to producing reliable results that others will have confidence in.</p>
<p class="baindent">The handling of instrumental &#x201C;errors&#x201D; such as noise is treated excellently in Wayne&#x2019;s book and a classic treatise on the treatment of errors in calculations can be found in Bevington.</p>
<section epub:type="chapter" id="ch5.3">
<h2 class="h2"><b>5.3 LIMS</b></h2>
<p class="banoindent">Laboratory information management systems (LIMS) are programs, or suites of programs, for the efficient acquisition, storage and manipulation of data. LIMS packages come in all shapes and sizes: some are just specialised databases allowing data to be organised, others have data acquisition programs integrated into them to allow raw data to be retrieved directly from an instrument into the system, but they can all be used to generate reports and create graphical output of the data.</p>
<p class="baindent">In general, LIMS systems are most often used in analytical laboratories where the same operation is performed on many different samples and where it is necessary to keep track of many thousands of items of data.</p>
</section>
</section>
</section>
</body>
</html>
